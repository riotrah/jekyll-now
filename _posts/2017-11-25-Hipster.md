---
layout: post
title: On Being a Hipster
---

Today I took a coding challenge for a company whose influence and sophistication had me nervously excited before I even opened their initial email. I **failed** the challenge. Why? I wasted my time wrangling a paradigm or set of techniques that I could only say I was comfortable enough to attempt under time pressure in the most wishful of mental states.

I was trying to throw into my code the most terse and beautiful syntax I could write with as many ES6 and functional programming constructs I thought I could juggle in my head, knowing full well all that mattered was passing some automated tests. My pseudo code was full of nested maps() and some() calls like I was some kind of functional ninja.

My last two Operating Systems homework assignment didn't have a single traditional for-loop each. You heard that correct, not even a for-in/for-of. And these were in Java (via Java 8 streams)! I managed to enable my technical obsession du jour in the most OOP language I knew. I had become a functional junkie.

But not even. I've barely even read RxJs's readme let alone played around with something like Haskell or Erlang, so I can't even call myself a true hipster with a passion for the slightly left of center. No. It appears I'm merely appropriating hipster behavior without the underlying infatuation with subversion.

It's in my music too. For a year and a half I played around in kooky guitar tunings, DADFAe this, CGCGCD that, making it impossible to collaborate with other musicians and stay in tune. I lost all versatility for the sake of the occasional new compositions aided by the creative boost of a technical challenge. While I've since recovered from my addiction to niche guitar tunings (I've only relapsed as far as Drop C) I realize I failed to become a better musician by incorporating any learnings from my experiments, but rather I created contrivances for their own sake. 

Now it's *thumping*. Tosin Abasi style. But also not even. Whereas Abasi makes use of his thumb to to double strike the same string before plucking it with the other fingers, I only strike once. Trust me it makes all the difference. It's a more half-assed approach whose similarity to its originating technique is arguable. I've been using and perhaps abusing this all the time now. Where I would have once used very even tremolo strokes with a pick, I now insist on ham-fisting with my thumping technique. I wonder what I will retain when I transistion to my next pseudo-obsession.

I used higher order functions in my code at work. Mostly becuase it works well: it allows me to avoid off-by-ones, handle array size checking, work statelessly and write readably, all with less bytes of code. But I don't know if I could write a solution to a time-based coding challenge at the edge of my seat in this paradigm to which I'm only an acquaintance. In fact, I couldn't.

I asked my roommate, who I respect as a logical problem solver, but who has no professional software development experience to attempt a solution. His algorithm was identical to mine at the higher-level, but while mine was bloated with unnecessarily modular functions, HashMaps for *everything* and nested map() calls, his was straightforward.

One function. 4 nested for loops at an unthinkable time complexity. But it was sound, straightforward, easy to debug and most importantly, just worked. 

Somewhere among my supposed ideals of authenticity is missing an awareness of my constant propensity for shiny new toys, paradigms and techniques. My beanie-wearing-wannabe-hipster ass weeps because by failing to even get working code, I failed to stand out.